.. _tutorial:

.. currentmodule:: prody

*******************************************************************************
Tutorial
*******************************************************************************

Foreword
===============================================================================

ProDy is designed for structure-based analysis of protein dynamics. 
It allows for quantitative analysis of heterogeneous experimental structural 
datasets and comparison with theoretically predicted conformational dynamics.
Experimental datasets include structural ensembles composed of sequence 
homologs, orthologs, mutant forms of a protein in the presence/absence of 
their substrates, ligands or inhibitors. Dominant patterns in structural 
variability are extracted by principal component analysis (PCA) of the 
datasets of structures. 

On the theoretical side, protein dynamics is predicted using 
normal mode analysis (NMA) based on elastic network models (ENMs) or 
is extracted from molecular dynamics (MD) trajectories using essential dynamics 
analysis (EDA). Numerous helper functions enable comparative analysis of thus 
obtained experimental and theoretical data, and visualize the principal changes 
in conformations that are accessible in different functional states.

In the interactive usage examples throughout the documentation, the input is 
the set of atomic coordinates of the query 
protein in PDB file format, or simply the PDB id or single letter amino acid 
sequence of the protein. Fast and flexible ProDy parsers are used to retrieve 
the corresponding dataset of PDB files from the PDB FTP server and 
extract the coordinate data and other relevant information. 

Results from PCA and NMA calculations can be plotted and saved as 
high-quality image files or visualized in VMD using :ref:`NMWiz` plug-in.  
In addition, ProDy allows for comparative analysis of PCA, NMA, or EDA results
generated by other software. User can input normal mode data in plain text 
files to use the rich library of analysis and plotting functions.

Using Prody and its Documentation
===============================================================================

ProDy can be used:

* interactively in a Python shell,
* as a command line program via :ref:`scripts`,
* from within VMD via :ref:`nmwiz`,
* or as a toolkit for developing new software.

Users who are new to Python are referred to `A Primer on Python for Life 
Science Researchers
<http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.0030199>`_
or the more comprehensive `The Python Tutorial 
<http://docs.python.org/tutorial/>`_.

ProDy documentation is organized in three main sections:

* Tutorial, contains brief usage examples of some ProDy features and is the 
  best place to start to learn ProDy.
* :ref:`examples` section contains comprehensive usage examples, which may be 
  applied to other cases after small modifications.
* :ref:`reference` section describes all ProDy classes and functions. 
  
  In interactive Python sessions, the reference documentation can be accessed 
  using the built-in Python function :func:`help`: 

  >>> help(parsePDB) # doctest: +SKIP

  This function prints the description of functions, classes, and class methods 
  to the screen. Note that you might need to type ``q`` to exit from 
  help. If you are using the interactive Python shell (IPython), you can also 
  receive help by typing::
  
    prot ?


Finally, the Tutorial, :ref:`examples` and :ref:`reference` 
pages contain ProDy code snippets. These snippets can be retrieved using 
the :guilabel:`Show Code Snippets` button on the right hand side panel. 
ProDy code will be displayed in a popup window. The code in the new page can 
be directly copied into a file. Click on the text, press :kbd:`Ctrl+A` and then 
:kbd:`Ctrl+C` to have the text in your clipboard.

.. image:: /_static/codesnippets.png
   :align: center
   :alt: Getting ProDy code snippets.

.. contents:: The ProDy Tutorial
   :local:
   :backlinks: none



Interactive usage
===============================================================================

One of our aims is making ProDy suitable for interactive usage by designing 
flexible functions and classes and giving them easy to remember names in a 
consistent manner. 

For best interactive usage experience, we strongly recommend 
that you use `IPython <http://ipython.scipy.org/>`_ or a similar 
interactive shell instead of the standard Python shell. The IPython shell, 
for example, provides user-friendly features, such as dynamic introspection
and help, and also optionally convenient integration of Numpy and Matplotlib
(see http://matplotlib.sourceforge.net).

In the rest of this tutorial, it is assumed that the user is typing commands 
in a Python shell. To begin the Tutorial, import all the functions and classes 
from ProDy into the current namespace as follows:

>>> from prody import *

Parse a PDB file
===============================================================================

Let's start with reading the contents of a PDB file. ProDy offers a fast PDB 
file parser function :func:`~proteins.parsePDB` (see 
:ref:`pdbparser-performance` for benchmarks). 
It is sufficient to pass a PDB identifier to read the file. The parser will 
seek a PDB file that matches given identifier in the current working directory, 
and if it is not found it will download it from the PDB FTP server automatically.

>>> prot = parsePDB('1p38')

The above example parses the coordinates and atomic data from the PDB file 1p38 
which contains an unbound structure of the p38 MAP kinase. :file:`1p38.pdb.gz` 
is downloaded, and coordinates and atomic data are returned in an 
:class:`~atomic.AtomGroup` instance.

To get information on the :class:`~prody.atomic.AtomGroup` instance, 
type in the variable name and hit :kbd:`enter` key:

>>> prot
<AtomGroup: 1p38 (2962 atoms; 1 coordinate sets, active set index: 0)>

The above shows that atom group object contains 2962 atoms. 
All atomic data from this object can be retrieved using ``get`` methods. 
For example:

>>> print prot.getResidueNames()
['GLU' 'GLU' 'GLU' ..., 'HOH' 'HOH' 'HOH']
>>> print prot.getCoordinates() # doctest: +SKIP
[[ 28.492   3.212  23.465]
 [ 27.552   4.354  23.629]
 [ 26.545   4.432  22.489]
 ..., 
 [ 18.872   8.33   36.716]
 [-22.062  21.632  42.029]
 [  1.323  30.027  65.103]]
 
The list of methods for getting and setting atomic data is provided in
:class:`~atomic.AtomGroup` reference documentation. 

More examples
-------------------------------------------------------------------------------

:func:`~proteins.parsePDB` function is very flexible and can be extremely
efficient depending on what you want to extract from a PDB file. It can be used
to parse specific chains, models, alternate locations, or well-defined 
subsets of atoms from a file. 
A detailed usage example can be found in :ref:`parsepdb`.

All of the functions for accessing and handling protein structural data are 
described in :mod:`~prody.proteins` module reference documentation.
:ref:`fetchpdb` and :ref:`blastpdb` examples show other ways to 
access the Protein Data Bank (|pdb|) content.


Select atoms
===============================================================================

ProDy :class:`~atomic.AtomGroup` instances have a plain view of atoms, but 
offer a powerful atom selection capability. You can get well defined subsets of 
atoms by passing simple :ref:`selection-keywords` as arguments or make 
sophisticated selections using composite arguments. Selection keywords and 
grammar is very much similar to those found in 
`VMD <http://www.ks.uiuc.edu/Research/vmd/>`_. We show some examples here.

*Select protein atoms*:

>>> protein = prot.select('protein')
>>> protein
<Selection: "protein" from 1p38 (2833 atoms; 1 coordinate sets, active set index: 0)>

Using the :term:`protein` keyword we selected 2833 atoms out of 2962 atoms. 
:meth:`~atomic.Atomic.select` method returned a :class:`~atomic.Selection` 
instance. Note that all ``get`` and ``set`` methods defined for
the :class:`~atomic.AtomGroup` class are also defined for 
:class:`~atomic.Selection` class. For example:

>>> print protein.getResidueNames()
['GLU' 'GLU' 'GLU' ..., 'ASP' 'ASP' 'ASP']

*Select atoms by* :term:`name`:

We select backbone atoms by passing atom names following :term:`name` keyword:

>>> backbone = prot.select('protein and name N CA C O')
>>> backbone
<Selection: "protein and name N CA C O" from 1p38 (1404 atoms; 1 coordinate sets, active set index: 0)>
>>> len(backbone)
1404

We can also use :term:`backbone` to make the same selection. 

*Select amino acids by name/type*:

We select acidic and basic residues by using residue names with 
:term:`resname` keyword:

>>> prot.select('resname ARG LYS HIS ASP GLU')
<Selection: "resname ARG LYS HIS ASP GLU" from 1p38 (906 atoms; 1 coordinate sets, active set index: 0)>

Alternatively, we can use predefined keywords :term:`acidic` and :term:`basic`.

>>> charged = prot.select('acidic or basic')
>>> charged
<Selection: "acidic or basic" from 1p38 (906 atoms; 1 coordinate sets, active set index: 0)>
>>> set(charged.getResidueNames())
set(['HIS', 'ASP', 'LYS', 'GLU', 'ARG'])

*A composite selection*:

Let's try a more sophisticated selection. We first calculate the geometric 
center of the protein atoms. Then, we select the Cα and Cβ atoms of residues 
that have at least one atom within 10 Å away from the geometric center.

>>> print protein.getCoordinates().mean(0) # doctest: +SKIP
[  1.005  17.533  40.052]
>>> prot.select('protein and name CA CB and same residue as ((x-1)**2 + (y-17.5)**2 + (z-40.0)**2)**0.5 < 10')
<Selection: "protein and nam...)**2)**0.5 < 10" from 1p38 (66 atoms; 1 coordinate sets, active set index: 0)>

More examples
-------------------------------------------------------------------------------

There is much more to what you can do with this flexible and fast atom 
selection engine, without the need for writing nested loops with comparisons 
or changing the source code. See the following pages:

  * :ref:`selections` for description of all selection keywords
  * :ref:`selection-examples` for a detailed usage example
  * :ref:`selection-operations` for handy features of :class:`~atomic.Selection`
    objects
  * :ref:`contacts` for selecting interacting atoms

Hierarchical views
===============================================================================

A hierarchical view of protein structure can be obtained by calling the 
:meth:`~atomic.AtomGroup.getHierView` method of the 
:class:`~atomic.AtomGroup` class. The function will return a 
(:class:`~atomic.HierView`) instance:

>>> hv = prot.getHierView()

We can use this view to access chains or residues:

>>> chA = hv['A']
>>> chA 
<Chain: A from 1p38 (2962 atoms; 1 coordinate sets, active set index: 0)>
>>> chAres10 = hv.getResidue('A', 10)
>>> chAres10
<Residue: ARG 10 from Chain A from 1p38 (11 atoms; 1 coordinate sets, active set index: 0)>

We can also iterate over chains and residues:

>>> for chain in hv: print chain
Chain A
>>> for res in hv.iterResidues(): print res
GLU 4
ARG 5
PRO 6
...
HOH 771
HOH 773
HOH 776

A more detailed usage example can be found in :ref:`hierview`.

Write a PDB file
===============================================================================

PDB files can be written using the :func:`~prody.proteins.writePDB` function.
The function accepts objects containing or referring to atomic data.

Writing selected atoms:

>>> writePDB('1p38_calphas.pdb', prot.select('calpha'))
'1p38_calphas.pdb'

Writing a chain:

>>> chain_A = hv.getChain('A')
>>> writePDB('1p38_chain_A.pdb', chain_A)
'1p38_chain_A.pdb'

As you may have noticed, this function returns the file name after it is
successfully written.

PCA calculations
===============================================================================

We show how to perform principal component analysis (:class:`~dynamics.PCA`) 
of a set of NMR models for ubiquitin (PDB ID: 2k39).

Parse and align the coordinate data:

>>> ubi = parsePDB('2k39', subset='calpha')
>>> ubi_selection = ubi.select('resnum < 71')
>>> ubi_ensemble = Ensemble(ubi_selection)
>>> ubi_ensemble.iterpose()

Perform the PCA:

>>> pca = PCA('Ubiquitin')
>>> pca.buildCovariance(ubi_ensemble)
>>> pca.calcModes()

Print the fraction of variance for top raking 4 PCs:

>>> for mode in pca[:4]:
...     print mode.getFractOfVariance() # doctest: +SKIP
0.133691677009
0.0942276000043
0.0833640062736
0.0654647139302

The :func:`~dynamics.writeNMD` function writes PCA results 
in NMD format. NMD files can be viewed using the :ref:`nmwiz` VMD plug-in.

>>> writeNMD('ubi_pca.nmd', pca[:3], ubi_selection)
'ubi_pca.nmd'

This was a short example for an easy case. :ref:`pca` section
contains more comprehensive examples for heterogeneous datasets. 

ANM calculations
===============================================================================

Anisotropic network model (:class:`~prody.dynamics.ANM`) analysis can be 
performed in two ways:

The shorter way, which may be suitable for interactive sessions:

>>> anm, atoms = calcANM(ubi_selection, selstr='calpha')

The longer and more controlled way:

>>> anm = ANM('ubi') # instantiate ANM object
>>> anm.buildHessian(ubi_selection) # build Hessian matrix for selected atoms 
>>> anm.calcModes() # calculate normal modes

:ref:`anm` provides a more detailed discussion of ANM calculations. 
The above longer way gives more control to the user. For example, instead of 
building the Hessian matrix using uniform force constant and cutoff distance, 
customized force constant functions (see :ref:`gamma`) or a pre-calculated matrix 
(see :meth:`~dynamics.ANM.setHessian`) may be used. 

Individual :class:`~dynamics.Mode` instances can be accessed by 
indexing the :class:`~dynamics.ANM` instance:

>>> slowest_mode = anm[0]
>>> print slowest_mode
Mode 1 from ANM ubi
>>> slowest_mode.getEigenvalue() # doctest: +SKIP
1.7142408905432185

Note that indices in Python start from zero (0). 
0th mode is the 1st non-zero mode in this case.

The :func:`~dynamics.writeNMD` function writes ANM results 
in NMD format. NMD files can be viewed using the :ref:`nmwiz` VMD plug-in. 

>>> writeNMD('p38_anm.nmd', anm[:6], ubi_selection) 
'p38_anm.nmd'

For more information on elastic network model calculations see
:ref:`enm` section.

Comparative analysis
===============================================================================

ProDy comes with many built-in functions to facilitate a comparative analysis
of experimental and theoretical data. For example, using 
:func:`~dynamics.printOverlapTable` function you can see the agreement between 
experimental (PCA) modes and theoretical (ANM) modes calculated above:

>>> printOverlapTable(pca[:4], anm[:4])
Overlap Table
                            ANM ubi
                     #1     #2     #3     #4
PCA Ubiquitin #1   -0.21  +0.30  -0.17  -0.47
PCA Ubiquitin #2   +0.01  +0.72  +0.08  +0.05
PCA Ubiquitin #3   +0.31  +0.11  +0.18  +0.19
PCA Ubiquitin #4   +0.11  -0.02  -0.17  -0.39
<BLANKLINE>

Output above shows that PCA mode 2 and ANM mode 2 for ubiquitin show the 
highest overlap (cosine-correlation). 

:ref:`pca-xray-analysis` shows more analysis function usage examples and 
:ref:`dynamics` module documentation lists all of the analysis functions. 

External NMA data 
===============================================================================

.. versionadded:: 0.5.3

Normal mode data from other NMA, EDA, or PCA programs can be parsed using
:func:`~dynamics.parseModes` function for ProDy analysis. 

In this case, we will parse ANM modes for p38 MAP Kinase calculated using 
`ANM server <http://ignmtest.ccbb.pitt.edu/cgi-bin/anm/anm1.cgi>`_ 
as the external software. We will use :download:`oanm.eigvals <doctest/oanm_eigvals.txt>` 
and :download:`oanm.slwevs <doctest/oanm_slwevs.txt>` files from the ANM server. 

You can either download these files to your current working directory from here
or obtain them for another protein from the ANM server.

>>> nma = parseModes(normalmodes='oanm_slwevs.txt', 
...                  eigenvalues='oanm_eigvals.txt', 
...                  nm_usecols=range(1,21), 
...                  ev_usecols=[1], ev_usevalues=range(6,26))
>>> nma
<NMA: oanm_slwevs (20 modes, 351 atoms)>
>>> nma.setName('1p38 ANM')
>>> slowmode = nma[0]
>>> slowmode.getEigenvalue() # doctest: +SKIP
0.1788

.. plot::
   :context:
   :nofigs:
   
   from prody import *
   nma = parseModes(normalmodes='oanm_slwevs.txt', eigenvalues='oanm_eigvals.txt', 
                  nm_usecols=range(1,21), ev_usecols=[1], ev_usevalues=range(6,26))
   nma.setName('1p38 ANM')
   slowmode = nma[0]

Plotting data 
===============================================================================

If you have Matplotlib, you can use ProDy functions whose name start with
``show`` to plot data:

.. plot::
   :include-source:
   :context:
   
   import matplotlib.pyplot as plt
   plt.figure( figsize=(5,4) )
   showSqFlucts( slowmode )
      
:ref:`pca-xray-plotting` shows more plotting examples and 
:ref:`dynamics` module documentation lists all of the plotting functions. 

ProDy verbosity
===============================================================================

Finally, you might have noted that ProDy prints some information to the console
after parsing a file or doing some calculations. For example, PDB parser will 
print what was parsed and how long it took to the screen::

  @> 1p38 (./1p38.pdb.gz) is found in the target directory.
  @> PDBParser: 2962 atoms and 1 coordinate sets were parsed in 0.08s.

The level of verbosity can be adjusted using :func:`changeVerbosity` function.
If you do not want any logs printed on the screen, you can enter 
``changeVerbosity(None)``.

Questions or suggestions
===============================================================================

If you have any questions or suggestions please contact us in one of the
following ways:

|questions|

|suggestions|
